template<int SZ> struct centroidDecomp {
    vi neighbor[SZ];
    int subsize[SZ];
    bool vis[SZ];
    int par[SZ];
    vi child[SZ];
    void addEdge(int u, int v) {
        neighbor[u].PB(v);
        neighbor[v].PB(u);
    }
    void build() {
        M00(i, SZ) {
            vis[i] = 0;
        }
        solve(0);
    }
    int getSizes(int node) {
        if(subsize[node] == -1) return 0; //this is its parent
        if(subsize[node] != 0) return subsize[node]; //we already computed
        subsize[node] = -1;
        int ans = 1;
        for(int ch: neighbor[node]) if(!vis[ch]) ans += getSizes(ch);
        subsize[node] = ans;
        return subsize[node];
    }
    int getCentroid(int root) { //get centroid in component containing root
        getSizes(root);
        int cur = root;
        int prev = cur;
        while(1) {
            pi hi = MP(-1, -1);
            for(int v: neighbor[root]) if(!vis[v] && v != prev) hi = max(hi, MP(subsize[v], v));
            if(hi.F <= SZ/2 || hi.F == -1) return cur;
            prev = cur;
            cur = hi.S;
        }
    }
    int solve(int node) {
        int cen = getCentroid(node);
        vis[cen] = 1;
        for(int ch: neighbor[node]) if(!vis[ch]) {
            int cen2 = solve(ch);
            par[cen2] = cen;
            child[cen].PB(cen2);
        }
        return cen;
    }
};
